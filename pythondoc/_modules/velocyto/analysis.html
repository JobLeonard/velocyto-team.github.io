

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>velocyto.analysis &mdash; velocyto 0.9.5 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="velocyto 0.9.5 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> velocyto
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome to velocyto.py!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fullapi/index.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/index.html">Notebooks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../citing/index.html">Authors and citations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license/index.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">velocyto</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>velocyto.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for velocyto.analysis</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy_groupies.aggregate_numpy</span> <span class="k">as</span> <span class="nn">npg</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">cdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span> <span class="k">as</span> <span class="n">normal</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">f</span> <span class="k">as</span> <span class="n">Fdistr</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">rankdata</span><span class="p">,</span> <span class="n">chi2</span>
<span class="kn">from</span> <span class="nn">statsmodels.sandbox.stats.multicomp</span> <span class="k">import</span> <span class="n">multipletests</span>
<span class="kn">import</span> <span class="nn">loompy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVR</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">non_negative_factorization</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVR</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">clusters_stats</span>
<span class="kn">from</span> <span class="nn">.neighbors</span> <span class="k">import</span> <span class="n">knn_distance_matrix</span><span class="p">,</span> <span class="n">connectivity_to_weights</span><span class="p">,</span> <span class="n">convolve_by_sparse_weights</span><span class="p">,</span> <span class="n">BalancedKNN</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">fit_slope</span><span class="p">,</span> <span class="n">fit_slope_offset</span><span class="p">,</span> <span class="n">fit_slope_weighted</span><span class="p">,</span> <span class="n">fit_slope_weighted_offset</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">fit_slope_multiq</span><span class="p">,</span> <span class="n">fit_slope_multiq_reg</span>
<span class="kn">from</span> <span class="nn">.estimation</span> <span class="k">import</span> <span class="n">colDeltaCor</span><span class="p">,</span> <span class="n">colDeltaCorLog10</span><span class="p">,</span> <span class="n">colDeltaCorpartial</span><span class="p">,</span> <span class="n">colDeltaCorSqrtpartial</span><span class="p">,</span> <span class="n">colDeltaCorLog10partial</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="k">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="o">*</span>


<div class="viewcode-block" id="VelocytoLoom"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom">[docs]</a><span class="k">class</span> <span class="nc">VelocytoLoom</span><span class="p">:</span>    
    <span class="sd">&quot;&quot;&quot;A convenient object to store the data of a velocyto loom file.</span>

<span class="sd">    Data will be stored in memory</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import velocyto as vcy</span>
<span class="sd">    &gt;&gt;&gt; vlm = vcy.VelocytoLoom(&quot;foo.loom&quot;)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    S: np.ndarray</span>
<span class="sd">        Expressed spliced molecules</span>
<span class="sd">    U: np.ndarray</span>
<span class="sd">        Unspliced molecule count</span>
<span class="sd">    A: np.ndarray</span>
<span class="sd">        Anbiguous molecule count</span>
<span class="sd">    ca: dict</span>
<span class="sd">        Column attributes of the loom file</span>
<span class="sd">    ra: dict</span>
<span class="sd">        Row attributes of the loom file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loom_filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span> <span class="o">=</span> <span class="n">loom_filepath</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;_Valid&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;fraction of _Valid cells is {np.mean(self.ca[&#39;_Valid&#39;])} but all will be taken in consideration&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The file did not specify the _Valid column attribute&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="VelocytoLoom.plot_fractions"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_fractions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save2file</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots a barplot of the abundance of spliced/unspliced of molecules in the dataset</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        save2file: str (default: None)</span>
<span class="sd">            If not None specifies the file path to wich plots get saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chips</span><span class="p">,</span> <span class="n">chip_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;SampleID&quot;</span><span class="p">],</span> <span class="n">return_inverse</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">chips</span><span class="p">,</span> <span class="n">chip_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;CellID&quot;</span><span class="p">]],</span> <span class="n">return_inverse</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chips</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">chip_ix</span><span class="p">):</span>
            <span class="n">tot_mol_cell_submatrixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[:,</span> <span class="n">chip_ix</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">]]</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tot_mol_cell_submatrixes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">_mean</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tot_mol_cell_submatrixes</span><span class="p">]</span>
            <span class="n">_std</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tot_mol_cell_submatrixes</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fraction&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_mean</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.05</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_mean</span><span class="p">,</span> <span class="n">_std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Hide the right and top spines</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Only show ticks on the left and bottom spines</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">,</span> <span class="s2">&quot;ambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;unspliced&quot;</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save2file</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save2file</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_cells"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_cells">[docs]</a>    <span class="k">def</span> <span class="nf">filter_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bool_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter cells that will be kept in the analysis</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        bool_array: np.ndarray (size )</span>
<span class="sd">            array describing the cells to keep (True)</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Nothing but it remove some cells from S and U </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">bool_array</span><span class="p">]</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">bool_array</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">bool_array</span><span class="p">]</span>  <span class="c1"># type: np.ndarray</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="VelocytoLoom.set_clusters"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.set_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">set_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cluter_colors_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colormap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">cluster_labels</span>
        <span class="k">if</span> <span class="n">cluter_colors_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cluter_colors_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster_labels</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="n">cluter_colors_dict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">colormap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="n">colormap_fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">)</span>
                <span class="n">cluster_uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cluster_uid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">colormap_fun</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_uid</span><span class="p">))}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">colormap</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">)</span>
                <span class="n">cluster_uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluter_colors_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cluster_uid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_uid</span><span class="p">))}</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_uid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">clusters_uid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clusters_uid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">cluster_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cluster_ix</span>

<div class="viewcode-block" id="VelocytoLoom.score_cv_vs_mean"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_cv_vs_mean">[docs]</a>    <span class="k">def</span> <span class="nf">score_cv_vs_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">min_expr_cells</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_expr_avg</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">svr_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">winsorize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">winsor_perc</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">),</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rank genes on the basis of a CV vs mean fit, it uses a nonparametric fit (Support Vector Regression)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        N: int</span>
<span class="sd">            the number to select</span>
<span class="sd">        min_expr_cells: int</span>
<span class="sd">            minimum number of cells that express that gene for it to be considered in the fit</span>
<span class="sd">        max_expr_avg: float</span>
<span class="sd">            The maximum average accepted before discarding from the the gene as house-keeping/outlier</span>
<span class="sd">        svr_gamma: float</span>
<span class="sd">            the gamma hyperparameter of the SVR</span>
<span class="sd">        plot: bool</span>
<span class="sd">            wether to show a plot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score: np.ndarray</span>
<span class="sd">            How much the observed CV is higher than the one predicted by a noise model fit to the data</span>
<span class="sd">            # the same array will be stored as the attribure `cv_mean_score`</span>
<span class="sd">        selected: np.ndarray bool</span>
<span class="sd">            on the basis of the N parameter</span>
<span class="sd">            # the same array will be stored as the attribure `cv_mean_selected`</span>

<span class="sd">        Note: genes excluded from the fit will have in the output the same score as the less noisy gene in the dataset.</span>
<span class="sd">        NOTE: The function returns more genes than N in case more genes with the same score as present. This may result</span>
<span class="sd">              in a cv vs mean plot that looks weirdly colored red/blue when looked at low magnification</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">winsorize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_expr_cells</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="n">winsor_perc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">):</span>
                <span class="n">min_expr_cells</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="n">winsor_perc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;min_expr_cells is too low for winsorization with upper_perc =</span><span class="si">{winsor_perc[0]}</span><span class="s2">, ugrading to min_expr_cells =</span><span class="si">{min_expr_cells}</span><span class="s2">&quot;</span><span class="p">)</span>
                
        <span class="n">detected_bool</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_expr_cells</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_expr_avg</span><span class="p">)</span>
        <span class="n">Sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">detected_bool</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">winsorize</span><span class="p">:</span>
            <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Sf</span><span class="p">,</span> <span class="n">winsor_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Sfw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">Sf</span><span class="p">,</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">Sfw</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">Sfw</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cv</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">mu</span>
        <span class="n">log_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">log_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">cv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">svr_gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">svr_gamma</span> <span class="o">=</span> <span class="mf">150.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;svr_gamma set to </span><span class="si">{svr_gamma}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Fit the Support Vector Regression</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">svr_gamma</span><span class="p">)</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">log_m</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">)</span>
        <span class="n">fitted_fun</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">fitted_fun</span><span class="p">(</span><span class="n">log_m</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">log_cv</span> <span class="o">-</span> <span class="n">ff</span>
        <span class="n">nth_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">score</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">N</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">scatter_viz</span><span class="p">(</span><span class="n">log_m</span><span class="p">[</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">[</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:red&quot;</span><span class="p">)</span>
            <span class="n">scatter_viz</span><span class="p">(</span><span class="n">log_m</span><span class="p">[</span><span class="n">score</span> <span class="o">&lt;=</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">log_cv</span><span class="p">[</span><span class="n">score</span> <span class="o">&lt;=</span> <span class="n">nth_score</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span>
            <span class="n">mu_linspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">log_m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">log_m</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mu_linspace</span><span class="p">,</span> <span class="n">fitted_fun</span><span class="p">(</span><span class="n">mu_linspace</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">detected_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span><span class="p">[</span><span class="o">~</span><span class="n">detected_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1e-16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span><span class="p">[</span><span class="n">detected_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span> <span class="o">&gt;=</span> <span class="n">nth_score</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected</span></div>

<div class="viewcode-block" id="VelocytoLoom.score_cluster_expression"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_cluster_expression">[docs]</a>    <span class="k">def</span> <span class="nf">score_cluster_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_avg_U</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">min_avg_S</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare filtering genes on the basis of knowledge on the cluster</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_avg_U: float</span>
<span class="sd">            Include genes that have unspliced average bigger than `min_avg_U` in at least one of the clusters</span>
<span class="sd">        min_avg_U: float</span>
<span class="sd">            Include genes that have spliced average bigger than `min_avg_U` in at least one of the clusters</span>
<span class="sd">        Note: the two conditions are combined by and &quot;&amp;&quot; logical operator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clu_avg_selected: np.ndarray bool</span>
<span class="sd">            The gene cluster that is selected</span>
<span class="sd">        Note: an attribute with the same name is created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_avgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_avgs</span> <span class="o">=</span> <span class="n">clusters_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_uid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_ix</span><span class="p">,</span> <span class="n">size_limit</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clu_avg_selected</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_avgs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_avg_U</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_avgs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_avg_S</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clu_avg_selected</span></div>

<div class="viewcode-block" id="VelocytoLoom.score_detection_levels"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.score_detection_levels">[docs]</a>    <span class="k">def</span> <span class="nf">score_detection_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_expr_counts</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">min_cells_express</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                               <span class="n">min_expr_counts_U</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_cells_express_U</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Prepare basic filtering of genes on the basis of their detection levels</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_expr_counts: float</span>
<span class="sd">            The minimum number of spliced molecules detected considering all the cells</span>
<span class="sd">        min_cells_express: float</span>
<span class="sd">            The minimum number of cells that express spliced molecules of a gene</span>
<span class="sd">        min_expr_counts_U: float</span>
<span class="sd">            The minimum number of unspliced molecules detected considering all the cells</span>
<span class="sd">        min_cells_express_U: float</span>
<span class="sd">            The minimum number of cells that express unspliced molecules of a gene</span>
<span class="sd">        Note: the conditions are combined by and &quot;&amp;&quot; logical operator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but an attribute self.detection_level_selected is created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some basic filtering</span>
        <span class="n">S_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_ncells_express</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">U_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">U_ncells_express</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">filter_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_sum</span> <span class="o">&gt;=</span> <span class="n">min_expr_counts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ncells_express</span> <span class="o">&gt;=</span> <span class="n">min_cells_express</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">U_sum</span> <span class="o">&gt;=</span> <span class="n">min_expr_counts_U</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">U_ncells_express</span> <span class="o">&gt;=</span> <span class="n">min_cells_express_U</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detection_level_selected</span> <span class="o">=</span> <span class="n">filter_bool</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_genes"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_genes">[docs]</a>    <span class="k">def</span> <span class="nf">filter_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by_detection_levels</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">by_cluster_expression</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">by_cv_vs_mean</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">by_custom_array</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_unfiltered</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter genes taking care that all the matrixes and all the connected annotation get filtered accordingly</span>

<span class="sd">        Attributes affected: .U, .S, .ra</span>
<span class="sd">        if present also: .ei_stats_matrix, .ei_stats_ra</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        by_detection_levels: bool, default=False</span>
<span class="sd">            filter genes by the score_detection_levels result</span>

<span class="sd">        by_cluster_expression: bool, default=True (NOTE: in legacy code was True)</span>
<span class="sd">            filter genes by the score_cluster_expression result</span>

<span class="sd">        by_cv_vs_mean: bool, default=True (NOTE: in legacy code was True)</span>
<span class="sd">            filter genes by the score_cluster_expression result</span>

<span class="sd">        by_custom_array, np.ndarray, default=None</span>
<span class="sd">            provide a booelan or index array</span>

<span class="sd">        keep_unfiltered: bool, default=False</span>
<span class="sd">            wether to create attributes self.S_prefilter, self.U_prefilter, self.ra_prefilter,</span>
<span class="sd">            optionally if present (self.ei_stats_matrix_prefilter, ei_stats_ra_prefilter)</span>
<span class="sd">            (array will be made sparse to minimize memory footprint)</span>
<span class="sd">            or just overwrite the previous arrays</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it updates the self.S, self.U, self.ra attributes</span>
<span class="sd">        (if present also self.ei_stats_matrix, ei_stats_ra)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">by_detection_levels</span><span class="p">,</span> <span class="n">by_cluster_expression</span><span class="p">,</span>
                       <span class="n">by_cv_vs_mean</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">by_custom_array</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)]),</span> <span class="s2">&quot;At least one of the filtering methods needs to be True&quot;</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">by_cluster_expression</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clu_avg_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;clu_avg_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by cluster expression&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">clu_avg_selected</span>
        <span class="k">if</span> <span class="n">by_cv_vs_mean</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cv_mean_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;cv_mean_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by cv vs mean&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_mean_selected</span>
        <span class="k">if</span> <span class="n">by_detection_levels</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;detection_level_selected&quot;</span><span class="p">),</span> <span class="s2">&quot;detection_level_selected was not found&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by detection level&quot;</span><span class="p">)</span>
            <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_level_selected</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">by_custom_array</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">by_custom_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by custom boolean array&quot;</span><span class="p">)</span>
                <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="n">by_custom_array</span>
            <span class="k">elif</span> <span class="n">by_custom_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filtering by custom index array&quot;</span><span class="p">)</span>
                <span class="n">bool_negative</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_filter</span><span class="p">)),</span> <span class="n">by_custom_array</span><span class="p">)</span>
                <span class="n">tmp_filter</span><span class="p">[</span><span class="n">bool_negative</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">keep_unfiltered</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;U_prefilter&quot;</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attributes *_prefilter are already present and were overwritten&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_prefilter</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_prefilter</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra_prefilter</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

<div class="viewcode-block" id="VelocytoLoom.custom_filter_genes"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.custom_filter_genes">[docs]</a>    <span class="k">def</span> <span class="nf">custom_filter_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">bool_filter</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">keep_unfiltered</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;It filter genes from multiple attributes, taking care if they are dictionaries or numpy arrays</span>
<span class="sd">        and if the unfiltered version need to be mantained</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>

<span class="sd">        attr_names: List[str]</span>
<span class="sd">            a list of the attributes to be modified. The can be</span>
<span class="sd">            1d arrays</span>
<span class="sd">            dictionary of 1d arrays</span>
<span class="sd">            nd arrays, will be filtered by axis=0</span>
<span class="sd">            if .T is specified by axis=-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.T&quot;</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">transpose_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">transpose_flag</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bool_filter</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="n">bool_filter</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;The filtering of an object of type {type(obj)} is not defined&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_normalize_S</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_S_size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_S_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cell_size&quot;</span><span class="p">):</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ucell_size</span> <span class="o">=</span> <span class="n">cell_size</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Uavg_size</span> <span class="o">=</span> <span class="n">avg_size</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">avg_size</span> <span class="o">/</span> <span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Unorm_factor</span> <span class="o">=</span> <span class="n">norm_factor</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># it happened only once but it is here as a preacution</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_Sx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relative_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xavg_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xnorm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

    <span class="k">def</span> <span class="nf">_normalize_Ux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_Sx_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cell_size&quot;</span><span class="p">):</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcell_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">relative_size</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="n">relative_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xUcell_size</span> <span class="o">=</span> <span class="n">cell_size</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">cell_size</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">avg_size</span> <span class="o">=</span> <span class="n">target_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xUavg_size</span> <span class="o">=</span> <span class="n">avg_size</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">avg_size</span> <span class="o">/</span> <span class="n">cell_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xUnorm_factor</span> <span class="o">=</span> <span class="n">norm_factor</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">norm_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># it happened only once but it is here as a precaution</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>  <span class="c1"># np.sqrt(S_sz )# np.log2(S_sz + 1)</span>

<div class="viewcode-block" id="VelocytoLoom.normalize"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">relative_size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_S_size_for_U</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Normalization for the count data</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which: either &#39;both&#39;, &#39;S&#39;, &#39;U&#39;, &quot;imputed&quot;, &quot;Sx&quot;, &quot;Ux&quot;</span>
<span class="sd">            which attributes to normalize.</span>
<span class="sd">            &quot;both&quot; corresponds to &quot;S&quot; and &quot;U&quot;</span>
<span class="sd">            &quot;imputed&quot; corresponds to &quot;Sx&quot; and &quot;Ux&quot;</span>
<span class="sd">        size: bool</span>
<span class="sd">            perform size normalization</span>
<span class="sd">        log: bool</span>
<span class="sd">            perform log normalization (if size==True, this comes after the size normalization)</span>
<span class="sd">        pcount: int, default: 1</span>
<span class="sd">            The extra count added when logging (log2)</span>
<span class="sd">        relative_size: np.ndarray, default=None</span>
<span class="sd">            if None it calculate the sums the mulecules per cell (self.S.sum(0))</span>
<span class="sd">            if an array is provided it use it for the normalization</span>
<span class="sd">        use_S_size_for_U: bool</span>
<span class="sd">            U is size normalized using the sum of molecules of S</span>
<span class="sd">        target_size: float or Tuple[float, float] (depending if the which parameter implies 1 or more normalizations)</span>
<span class="sd">            the size of the cells after normalization will be set to.</span>
<span class="sd">            If tuple the order is (S, U) or (Sx, Ux)</span>
<span class="sd">            If None the target size is the average of the cell sizes</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but creates the attributes `U_norm`, `U_sz` and `S_norm`, &quot;S_sz&quot;</span>
<span class="sd">        or `Ux_norm`, `Ux_sz` and `Sx_norm`, &quot;Sx_sz&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_S_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;U&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_S_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;imputed&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Sx</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Ux</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;Sx&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Sx</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;Ux&quot;</span> <span class="o">==</span> <span class="n">which</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_Ux</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="n">use_Sx_size</span><span class="o">=</span><span class="n">use_S_size_for_U</span><span class="p">,</span> <span class="n">relative_size</span><span class="o">=</span><span class="n">relative_size</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_PCA"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_PCA">[docs]</a>    <span class="k">def</span> <span class="nf">perform_PCA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;S_norm&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">div_by_std</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">mult_by_scalefact</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S_norm</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">div_by_std</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">S_norm</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">S_norm</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># elif mult_by_scalefact:</span>
        <span class="c1">#     self.pcs = self.pca.fit_transform(self.S.T * self.gene_scale_fact)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">S_norm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.normalize_by_total"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize_by_total">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_by_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_perc_U</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Normalize the cells using the (initial) total moluecules as size estimate</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        min_perc_U: float</span>
<span class="sd">            the percentile to use as a minimum value allowed for the size normalization</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_cell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">)</span>
        <span class="n">min_Ucell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">min_perc_U</span><span class="p">)</span>
        <span class="n">bool_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span> <span class="o">&lt;</span> <span class="n">min_Ucell_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span> <span class="o">=</span> <span class="n">bool_f</span>
        <span class="n">target_Ucell_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">])</span>  <span class="c1"># 0.15 * target_cell_size</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;total spliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;total unspliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">[</span><span class="n">bool_f</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">)[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">)[</span><span class="n">bool_f</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;log total spliced&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log total unspliced&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_S</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_cell_size</span><span class="p">,</span>
                          <span class="n">target_size</span><span class="o">=</span><span class="n">target_cell_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span> <span class="n">min_Ucell_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                              <span class="n">target_size</span><span class="o">=</span><span class="n">target_Ucell_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_U</span><span class="p">(</span><span class="n">relative_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_Ucell_size</span><span class="p">,</span>
                              <span class="n">target_size</span><span class="o">=</span><span class="n">target_Ucell_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.adjust_totS_totU"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.adjust_totS_totU">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_totS_totU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize_total</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">fit_with_low_U</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">svr_C</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">svr_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Fit a smooth line to the relation S_sz_tot and U_sz_tot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">svr</span> <span class="o">=</span> <span class="n">SVR</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="n">svr_C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">svr_gamma</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit_with_low_U</span><span class="p">:</span>
            <span class="n">svr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">svr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">svr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">])</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">predicted</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">svr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
            
        <span class="n">adj_factor</span> <span class="o">=</span> <span class="n">predicted</span> <span class="o">/</span> <span class="n">y</span>
        <span class="n">adj_factor</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">adj_factor</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="n">adj_factor</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">*</span> <span class="n">adj_factor</span>

        <span class="k">if</span> <span class="n">normalize_total</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_median</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;renormalize&quot;</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="o">=</span><span class="n">skip_low_U_pop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">predicted</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.normalize_median"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.normalize_median">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;imputed&quot;</span><span class="p">,</span> <span class="n">skip_low_U_pop</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;renormalize&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;imputed&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">skip_low_U_pop</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">small_U_pop</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_pca"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_pca">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">elev</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">azim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">140</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                   <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="n">azim</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_PCA_imputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_PCA_imputed">[docs]</a>    <span class="k">def</span> <span class="nf">perform_PCA_imputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcax</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcax</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_norm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_pca_imputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_pca_imputed">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pca_imputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">elev</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">azim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=-</span><span class="mi">140</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">pcsx</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                   <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span> <span class="n">azim</span><span class="o">=</span><span class="n">azim</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.knn_imputation"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.knn_imputation">[docs]</a>    <span class="k">def</span> <span class="nf">knn_imputation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pca_space</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_pca_dims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">maximum</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">size_norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">balanced</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">b_sight</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">b_maxl</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs k-nn imputation</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        pca_space: bool, default=True</span>
<span class="sd">            if True the knn will be performed on self.pca</span>
<span class="sd">            otherwise it will use self.S_norm (log2 size normalized data)</span>
<span class="sd">        diag: int</span>
<span class="sd">            before smoothing this value is substituted in the diagonal of the knn contiguity matrix</span>
<span class="sd">            Resulting in a reduction of the smoothing effect</span>
<span class="sd">            E.g. if diag=8 and k=10 value of Si = (8 * S_i + sum(S_n, with n in 5nn of i)) / (8+5)</span>
<span class="sd">        maximum: bool</span>
<span class="sd">            wether to take the maximum value of the smoothing and the original matrix</span>
<span class="sd">        metric: str</span>
<span class="sd">            &quot;euclidean&quot; or &quot;correlation&quot;</span>
<span class="sd">        k: int</span>
<span class="sd">            number of neighbours</span>
<span class="sd">        n_pca_dims: int, default=None</span>
<span class="sd">            number of pca to use for the knn distance metric. If None all pcs will be used. (used only if pca_space == True)</span>
<span class="sd">        balanced: bool</span>
<span class="sd">            wheter to use BalancedKNN verison</span>
<span class="sd">        b_sight: int</span>
<span class="sd">            the sight parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        b_maxl: int</span>
<span class="sd">            the maxl patamenter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        n_jobs: int, default 8</span>
<span class="sd">            number of parallel jobs in knn calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        `knn`: sparse matrix</span>
<span class="sd">        `knn_smoothig_w`: the weights used for the smoothing</span>
<span class="sd">        `Sx`, `Ux`: the imputed values</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pca_space</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_pca_dims</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_norm</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">bknn</span> <span class="o">=</span> <span class="n">BalancedKNN</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">sight_k</span><span class="o">=</span><span class="n">b_sight</span><span class="p">,</span> <span class="n">maxl</span><span class="o">=</span><span class="n">b_maxl</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">bknn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">=</span> <span class="n">bknn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">=</span> <span class="n">knn_distance_matrix</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>  <span class="c1"># SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.</span>
            <span class="n">connectivity</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span> <span class="o">=</span> <span class="n">connectivity_to_weights</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size_norm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maximum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.knn_imputation_precomputed"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.knn_imputation_precomputed">[docs]</a>    <span class="k">def</span> <span class="nf">knn_imputation_precomputed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">:</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs k-nn imputation (like `.knn_imputation()`) but with a precomputed weight matrix</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        knn_smoothig_w: sparse.lil_matrix</span>
<span class="sd">            the sparse matrix to be convolved with self.S_sz and self.U_sz</span>
<span class="sd">            This should be the result of somethign like:</span>
<span class="sd">            connectivity.setdiag(diagonal_value)</span>
<span class="sd">            knn_smoothig_w = connectivity_to_weights(connectivity)</span>
<span class="sd">        maximum: bool, default=False</span>
<span class="sd">            wether to take the maximum value of the smoothing and the original matrix</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        Sx, Ux: the imputed values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="n">knn_smoothig_w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maximum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.gene_knn_imputation"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.gene_knn_imputation">[docs]</a>    <span class="k">def</span> <span class="nf">gene_knn_imputation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">diag</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scale_weights</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">balanced</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">b_sight</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">b_maxl</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span>
                            <span class="n">pca_space</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Performs genes k-nn imputation</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        metric: str, default=&quot;correlation&quot;</span>
<span class="sd">            &quot;euclidean&quot; or &quot;correlation&quot;</span>
<span class="sd">        k: int, defaut=15</span>
<span class="sd">            number of neighbours</span>
<span class="sd">        diag: int, default=1</span>
<span class="sd">            before smoothing this value is substituted in the diagonal of the knn contiguity matrix</span>
<span class="sd">            Resulting in a reduction of the smoothing effect</span>
<span class="sd">            E.g. if diag=8 and k=10 value of Si = (8 * S_i + sum(S_n, with n in 5nn of i)) / (8+5)</span>
<span class="sd">        scale_weights: bool, default=True</span>
<span class="sd">            wether to scale weights by gene total expression/yield</span>
<span class="sd">        balanced: bool, dafault=True</span>
<span class="sd">            wheter to use BalancedKNN verison</span>
<span class="sd">        b_sight: int, default=100</span>
<span class="sd">            the sight parameter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        b_maxl: int, default=18</span>
<span class="sd">            the maxl patamenter of BalancedKNN (used only if balanced == True)</span>
<span class="sd">        pca_space: bool, default=False</span>
<span class="sd">            if True the knn will be performed on self.pca</span>
<span class="sd">            otherwise it will use self.S_norm (log2 size normalized data)</span>
<span class="sd">        n_jobs: int, default=8</span>
<span class="sd">            number of parallel jobs in knn calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it creates the attributes:</span>
<span class="sd">        `gknn`: sparse matrix</span>
<span class="sd">        `gknn_smoothig_w`: the weights used for the smoothing</span>
<span class="sd">        `Sx`, `Ux`: the imputed values</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pca_space</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>  <span class="c1"># imputed size normalized counts</span>
        <span class="k">if</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">bknn</span> <span class="o">=</span> <span class="n">BalancedKNN</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">sight_k</span><span class="o">=</span><span class="n">b_sight</span><span class="p">,</span> <span class="n">maxl</span><span class="o">=</span><span class="n">b_maxl</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">bknn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn</span> <span class="o">=</span> <span class="n">bknn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn</span> <span class="o">=</span> <span class="n">knn_distance_matrix</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">atype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">connectivity</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span> <span class="o">=</span> <span class="n">connectivity_to_weights</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scale_weights</span><span class="p">:</span>
            <span class="n">genes_total</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span> <span class="o">=</span> <span class="n">scale_to_match_median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">)</span>
        <span class="c1"># NOTE This might be not computationally efficient after transpose, maybe better to use csc for the genes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">=</span> <span class="n">convolve_by_sparse_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gknn_smoothig_w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>
        
<div class="viewcode-block" id="VelocytoLoom.fit_gammas"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.fit_gammas">[docs]</a>    <span class="k">def</span> <span class="nf">fit_gammas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steady_state_bool</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_imputed_data</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_size_norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">single_q</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fixperc_q</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighted</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="s2">&quot;maxmin_diag&quot;</span><span class="p">,</span>
                   <span class="n">limit_gamma</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">98</span><span class="p">],</span> <span class="n">maxmin_weighted_pow</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fit gamma without intercepts of the gene components</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>

<span class="sd">        q_positive: bool, default=False</span>
<span class="sd">            Wether to constrain q to positive values</span>
<span class="sd">        multiple_qs</span>
<span class="sd">            Fit with one offset for each neighborhood</span>
<span class="sd">        single_q</span>
<span class="sd">            Fit with offset</span>
<span class="sd">        weighted</span>
<span class="sd">            weighted fit without offset</span>
<span class="sd">        weights</span>
<span class="sd">            values that get multiplied to the squared residuals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">steady_state_bool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span> <span class="o">=</span> <span class="n">steady_state_bool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_imputed_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_size_norm</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_size_norm</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmpS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
                <span class="n">tmpU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>

        <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmpU</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpU</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">tmpU</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpU</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_weighted&quot;</span><span class="p">:</span>
                <span class="c1"># Slightly smoother than just takin top and bottom percentile</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Do this asymmetrically, data is sparse!</span>
                <span class="n">Srange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">Srange</span> <span class="o">-=</span> <span class="n">Srange</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Srange</span> <span class="o">/=</span> <span class="n">Srange</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Srange</span><span class="o">**</span><span class="n">maxmin_weighted_pow</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Srange</span><span class="p">)</span><span class="o">**</span><span class="n">maxmin_weighted_pow</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin&quot;</span><span class="p">:</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmpS</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Do this asymmetrically, data is sparse!</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmpS</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">tmpS</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_diag&quot;</span><span class="p">:</span>
                <span class="n">Sx_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="c1"># Original code where I am actually projectin, but there is no need</span>
                <span class="c1"># downS, upS = np.percentile(Sx_maxnorm, [0.05, 99.9], 1)</span>
                <span class="c1"># downU, upU = np.percentile(Ux_maxnorm, [0.05, 99.9], 1)</span>
                <span class="c1"># d = ((upU - downU) / (upS - downS))</span>
                <span class="c1"># diag_v = np.column_stack([np.ones_like(upU), gamma]) # diag_v = np.ones((Sx_maxnorm, 2)) / np.sqrt(2)</span>
                <span class="c1"># diag_v = diag_v / np.linalg.norm(diag_v, 2, 1)[:, None]</span>
                <span class="c1"># # dot product manually</span>
                <span class="c1"># X = (Sx * diag_v[:,0:1] + Ux * diag_v[:,1:2])</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">Sx_maxnorm</span> <span class="o">+</span> <span class="n">Ux_maxnorm</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;maxmin_double&quot;</span><span class="p">:</span>
                <span class="n">Sx_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_maxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">Sx_maxnorm</span> <span class="o">+</span> <span class="n">Ux_maxnorm</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">down</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="n">maxmin_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">+=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">&lt;=</span> <span class="n">down</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">&gt;=</span> <span class="n">up</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">single_q</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R2</span> <span class="o">=</span> <span class="n">fit_slope_weighted_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                         <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                         <span class="n">W</span><span class="p">,</span>
                                                                         <span class="n">return_R2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">limit_gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">fixperc_q</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_weighted_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                                <span class="n">W</span><span class="p">,</span> <span class="n">fixperc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">fit_slope_offset</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                       <span class="n">fixperc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weighted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">=</span> <span class="n">fit_slope_weighted</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                 <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                                 <span class="n">W</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">=</span> <span class="n">fit_slope</span><span class="p">(</span><span class="n">tmpU</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">],</span>
                                        <span class="n">tmpS</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady_state</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.filter_genes_good_fit"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.filter_genes_good_fit">[docs]</a>    <span class="k">def</span> <span class="nf">filter_genes_good_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minR</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">min_gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># NOTE Should be: tmp_filter = np.sqrt(self.R2) &gt; minR but since the fit is weighted and constrained R2 can be negative</span>
        <span class="n">R_corrected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R2</span><span class="p">)</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">R_corrected</span> <span class="o">&gt;</span> <span class="n">minR</span>
        <span class="n">tmp_filter</span> <span class="o">=</span> <span class="n">tmp_filter</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">&gt;</span> <span class="n">min_gamma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">tmp_filter</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">matrixes2filter</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;U_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;U_norm&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;Ux_norm&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;S_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;S_norm&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">,</span> <span class="s2">&quot;Sx_norm&quot;</span><span class="p">]</span>
        <span class="n">vectors2filter</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gammas&quot;</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;R2&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name_attr</span> <span class="ow">in</span> <span class="n">matrixes2filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">)[</span><span class="n">tmp_filter</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">name_attr</span> <span class="ow">in</span> <span class="n">vectors2filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">)[</span><span class="n">tmp_filter</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.predict_U"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.predict_U">[docs]</a>    <span class="k">def</span> <span class="nf">predict_U</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;gammas&quot;</span><span class="p">,</span> <span class="n">which_S</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">,</span> <span class="n">which_offset</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Predict U given the gamma model fit</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which_gamma: str, default=&quot;gammas&quot;</span>
<span class="sd">            name of the attribute to use as gamma</span>
<span class="sd">        which_S: str, default=&quot;Sx_sz&quot;</span>
<span class="sd">            name of the attribute to use as S</span>
<span class="sd">        which_offset: str, default=None</span>
<span class="sd">            (optional) offset has to be used specify which attribute to use</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        Noting but it creates the attribute</span>
<span class="sd">         .Upred</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">=</span> <span class="n">which_S</span>
        <span class="k">if</span> <span class="n">which_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;q_W&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Predicting U without intercept but intercept was previously fit! Set which_offset=&#39;q&#39; or &#39;q_W&#39; &quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_S</span><span class="p">)</span>
            <span class="c1"># self.Upred = selg.gammas[:, None] * self.Sx_sz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_gamma</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_S</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_offset</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_velocity"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;M-value&quot;</span><span class="p">,</span> <span class="n">pcount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size_normalized</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate velocity or related parameter parameter</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        kind: str, default=&quot;M-value&quot;</span>
<span class="sd">            &quot;M-value&quot; calculates the M value as log2(U_measured) - log2(U_predicted)</span>
<span class="sd">            &quot;M-valueKNN&quot; calculates the M value as using gene KNN</span>
<span class="sd">            &quot;residual&quot; calculates the velocity as U_measured) - U_predicted</span>
<span class="sd">            &quot;MW-value&quot; calculates the M value as log2(WUpred.dot(H)) - np.log2(WU.dot(H))</span>
<span class="sd">        pcount: float, default=1</span>
<span class="sd">            (only used in kind=&quot;M-value&quot;) pseudocount to add to the reads/molecule counts before log2 transforming</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M-value&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Upred</span> <span class="o">+</span> <span class="n">pcount</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;residual&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Upred</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Not implemented with which_S = </span><span class="si">{self.which_S_for_pred}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Velocity calculation kind=</span><span class="si">{kind}</span><span class="s2"> is not implemented&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_shift"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_shift">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;log2_ratio&quot;</span><span class="p">,</span> <span class="n">assumption</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;constant_velocity&quot;</span><span class="p">,</span>
                        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_S</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find the change in gene expression for every cell</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        kind: str, default=&quot;log2_ratio&quot;</span>
<span class="sd">            difference</span>
<span class="sd">            log2_ratio</span>
<span class="sd">            log2_ratioW</span>
<span class="sd">        assumption: str, default=&quot;constant_velocity&quot;</span>
<span class="sd">            constant_velocity</span>
<span class="sd">            constant_unspliced</span>
<span class="sd">        min_S: float, default=min_S</span>
<span class="sd">            constant small value added in case of log2_ratio estimation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing it only creates the following attributes</span>
<span class="sd">         .delta_S</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">assumption</span> <span class="o">==</span> <span class="s2">&quot;constant_velocity&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;difference&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span>
                <span class="c1"># self.delta_S = delta_t * self.velocity</span>
                <span class="c1"># self.delta_S = delta_t * (self.Ux_sz - self.Upred)</span>
                <span class="c1"># self.delta_S = delta_t * self.Ux_sz * (1 - self.Upred / self.Ux_sz)</span>
                <span class="c1"># self.delta_S = delta_t * self.Ux_sz * (1 - 2**-self.M)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;log2_ratio&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**-</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

                <span class="c1"># # The alternative would be</span>
                <span class="c1"># # self.delta_S = delta_t * self.velocity</span>
                <span class="c1"># # self.delta_S = delta_t * (self.Ux_sz - self.Upred)</span>
                <span class="c1"># # self.delta_S = delta_t * self.Upred * (1 - self.Ux_sz / self.Upred)</span>
                <span class="c1"># # self.delta_S = delta_t * self.Sx_sz * gammas_optimized * (1 - self.M)</span>
                <span class="c1"># gammas_optimized = optimize_match_gamma(self.Sx_sz, self.Ux_sz, self.M, kind=&quot;differnece&quot;)</span>
                <span class="c1"># self.delta_S = delta_t * self.Sx_sz * gammas_optimized * (1 - 2**self.M)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Kind </span><span class="si">{kind}</span><span class="s2"> is not implemented for assumpition </span><span class="si">{assumption}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">assumption</span> <span class="o">==</span> <span class="s2">&quot;constant_unspliced&quot;</span><span class="p">:</span>
            <span class="c1"># Ux_sz = self.Ux_sz - offset; Ux_sz[Ux_sz&lt;0] = 0</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;difference&quot;</span><span class="p">:</span>  <span class="c1"># maybe I should say ratio see below</span>
                <span class="n">Ux_szo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">Ux_szo</span><span class="p">[</span><span class="n">Ux_szo</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">egt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gammas</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">*</span> <span class="n">egt</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">egt</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ux_szo</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammas</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>
                <span class="c1"># self.delta_S = self.Sx_sz * (egt + (1 - egt) * self.Ux_sz / (self.gamma * self.Sx_sz)) - self.Sx_sz</span>
                <span class="c1"># self.delta_S = self.Sx_sz * (egt + (1 - egt) * self.Ux_sz / self.Upred) - self.Sx_sz</span>
                <span class="c1"># self.delta_S = self.Sx_sz * (egt * (1 -  2**self.M) + 2**self.M  ) - self.Sx_sz</span>

            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;log2_ratio&quot;</span><span class="p">:</span>
                <span class="n">gammas_optimized</span> <span class="o">=</span> <span class="n">optimize_match_gamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ux_sz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;log2_ratio&quot;</span><span class="p">)</span>
                <span class="c1"># NOTE there is a more naive alternative to this extimation</span>
                <span class="n">egt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gammas_optimized</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">+</span> <span class="n">min_S</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">egt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Kind </span><span class="si">{kind}</span><span class="s2"> is not implemented for assumpition </span><span class="si">{assumption}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Assumpution </span><span class="si">{assumption}</span><span class="s2"> is not implemented&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.extrapolate_cell_at_t"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.extrapolate_cell_at_t">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolate_cell_at_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">clip</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find the value for the cell after time delta_t</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span>
            <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span>
            <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not implemented for other situation other than Sx or Sx_sz&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.perform_TSNE"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.perform_TSNE">[docs]</a>    <span class="k">def</span> <span class="nf">perform_TSNE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">initial_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_pca_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform TSNE on the PCA using barnes hut approximation (C implementation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform TSNE</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Running bhtsne&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_pos</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="n">bh_tsne</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">initial_pos</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">bh_tsne</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcs</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_pca_dim</span><span class="p">])</span></div>

<div class="viewcode-block" id="VelocytoLoom.arrows_from_hidim_to_embedding"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.arrows_from_hidim_to_embedding">[docs]</a>    <span class="k">def</span> <span class="nf">arrows_from_hidim_to_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;pcsw&quot;</span><span class="p">,</span> <span class="n">ndims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
                                       <span class="n">max_dist_hidim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">embed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;tsW&quot;</span><span class="p">,</span> <span class="n">max_dist_embed</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">renormalize_to_norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Project the arrows from an high dimensional space to a low dimensional space by kNN decomposition</span>
<span class="sd">        </span>
<span class="sd">        DEPRECATED</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        hidim: str</span>
<span class="sd">            The name of the attribute containing the high dimensional space. It will be retrieved as getattr(self, hidim)</span>
<span class="sd">            The updated vector at time t is assumed to be getattr(self, hidim + &quot;_t&quot;)</span>
<span class="sd">        ndims: int</span>
<span class="sd">            The number of dimensions of the high dimensional space to work in when decomposing and calculating kNN.</span>
<span class="sd">        n_neighbors: int</span>
<span class="sd">            The number of neighbours to take into account</span>
<span class="sd">        max_dist_hidim: float, default=None</span>
<span class="sd">            The maximum distance that is accepted for the kNN graph before dropping the neighbour</span>
<span class="sd">            If None it will be set to 0.25 * average_distance_two_points_taken_at_random</span>
<span class="sd">        embed: str</span>
<span class="sd">            The name of the attribute containing the embedding. It will be retrieved as getattr(self, embed)</span>
<span class="sd">        max_dist_embed: float, default=None</span>
<span class="sd">            The maximum distance allowed</span>
<span class="sd">            If None it will be set to 0.25 * average_distance_two_points_taken_at_random</span>
<span class="sd">        renormalize_to_norm: bool, default=False</span>
<span class="sd">            If true then the sum of the projections need to have the same magnitude as the orginal vector.</span>
<span class="sd">            This forces the arrow to point within the manifiold so it is more conservative to set it to False</span>
<span class="sd">        n_jobs: int</span>
<span class="sd">            number of jobs to calkulate knn</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate nearest neighbours</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
        <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">)</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">)</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">ix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Don&#39;t consider self as neighbour</span>
        
        <span class="c1"># Prune according to maximum distance</span>
        <span class="k">if</span> <span class="n">max_dist_hidim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">randomly_picked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">hi_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">hi_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">max_dist_hidim</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">[</span><span class="n">randomly_picked</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_dist_hidim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># This is like dropping neighbours but mantains the shape of d, that is handy for broadcasting</span>
        
        <span class="c1"># Find the vector point-&gt;neighbour for each neighbour.</span>
        <span class="c1"># This is rappresented as a 3d_array (n_cells, n_neighbours, n_dims). Keep this in mind!</span>
        <span class="c1"># NOTE: I use numpy-broadcasting to quickly perform various operation including dot products!!!</span>
        <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Find unitary vector in the direction point-&gt;neighbourg for each neighbour.</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">uvector_i2nn</span> <span class="o">=</span> <span class="n">vector_i2nn</span> <span class="o">/</span> <span class="n">d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">uvector_i2nn</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">uvector_i2nn</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Make sure everything is a finite number otherwise zero the number</span>
        
        <span class="c1"># Calculate the velocity arrow and project it onto the unitary vector</span>
        <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
        <span class="n">proj_coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">uvector_i2nn</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># this is the dot product written using numpy broadcasting</span>
        
        <span class="k">if</span> <span class="n">renormalize_to_norm</span><span class="p">:</span>
            <span class="n">resulting_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">proj_coeff</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">uvector_i2nn</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">magnitude_resulting_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">resulting_vector</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">proj_coeff</span> <span class="o">=</span> <span class="n">proj_coeff</span> <span class="o">/</span> <span class="n">magnitude_resulting_vector</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        
        <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
        <span class="c1"># Find the vector point-&gt;hidim_neighbour in the embedding.</span>
        <span class="n">vector_i2nn_embed</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">embedding</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">d_embed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_i2nn_embed</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_dist_embed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">randomly_picked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">max_dist_embed</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">randomly_picked</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">d_embed</span><span class="p">[</span><span class="n">d_embed</span> <span class="o">&gt;</span> <span class="n">max_dist_embed</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># This drops the neighbours in low dim</span>
        <span class="n">d_embed</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># This drops the neighbours that were dorpped in hidim</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">uvector_i2nn_embed</span> <span class="o">=</span> <span class="n">vector_i2nn_embed</span> <span class="o">/</span> <span class="n">d_embed</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">uvector_i2nn_embed</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">uvector_i2nn_embed</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="p">(</span><span class="n">proj_coeff</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">uvector_i2nn_embed</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_t</span> <span class="o">=</span> <span class="n">embedding</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_local_correlations"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_local_correlations">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_local_correlations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;pcsw&quot;</span><span class="p">,</span> <span class="n">embed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;tsW&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">ndims</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">psc</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                                     <span class="n">knn_random</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sampled_fraction</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">delta_kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;clipped&quot;</span><span class="p">,</span>
                                     <span class="n">sampling_pobs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">max_dist_embed</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">15071990</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Uses correlation to estimate transition probabilities for every cells to its embedding neighborhood</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        hidim: str</span>
<span class="sd">            The name of the attribute containing the high dimensional space. It will be retrieved as getattr(self, hidim)</span>
<span class="sd">            The updated vector at time t is assumed to be getattr(self, hidim + &quot;_t&quot;)</span>
<span class="sd">            Appending .T to the string will transpose the matrix (usefull in case we want to use S or Sx)</span>
<span class="sd">        embed: str</span>
<span class="sd">            The name of the attribute containing the embedding. It will be retrieved as getattr(self, embed)</span>
<span class="sd">        transform: str, default=None</span>
<span class="sd">            The transformation that is applies on the high dimensional space.</span>
<span class="sd">            If None the raw data will be used</span>
<span class="sd">        ndims: int, default=None</span>
<span class="sd">            The number of dimensions of the high dimensional space to work with. If None all will be considered</span>
<span class="sd">            It makes sense only when using principal components</span>
<span class="sd">        n_neighbors: int, default=80</span>
<span class="sd">            The number of neighbours to take into account</span>
<span class="sd">        delta_kind: clipped, unclipped, residual</span>

<span class="sd">        max_dist_embed: float, default=None</span>
<span class="sd">            CURRENTLY NOT USED</span>
<span class="sd">            The maximum distance allowed</span>
<span class="sd">            If None it will be set to 0.25 * average_distance_two_points_taken_at_random</span>
<span class="sd">        n_jobs: int, default=4</span>
<span class="sd">            number of jobs to calkulate knn</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;</span> <span class="mi">150</span><span class="p">:</span>
            <span class="c1"># NOTE: this is DEPRECATED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">=</span> <span class="s2">&quot;knn&quot;</span>

            <span class="k">if</span> <span class="s2">&quot;pcs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hidim</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>

            <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate KNN in the embedding space&quot;</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="c1"># Calculate nearest neighbours in the embedding</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="c1"># d, ix = d[:, 1:], ix[:, 1:] /or/ d, ix = nn.kneighbors()  # Don&#39;t consider self as neighbour</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_ix</span> <span class="o">=</span> <span class="n">ix</span>
            
            <span class="c1"># Prune according to maximum distance</span>
            <span class="c1"># if max_dist_hidim is None:</span>
            <span class="c1">#     randomly_picked = np.random.choice(hi_dim.shape[0], np.minimum(500, hi_dim.shape[0]))</span>
            <span class="c1">#     max_dist_hidim = 0.25 * np.mean(pdist(hi_dim[randomly_picked, :]))</span>
            <span class="c1"># bool_max_dist = d &gt; max_dist_hidim</span>
            <span class="c1">#  d[bool_max_dist] = np.inf  # This is like dropping neighbours but mantains the shape of d, that is handy for broadcasting</span>
            
            <span class="c1"># Correlation calculation</span>
            <span class="c1"># NOTE: it should be parallelized and avoid big memory allocation of vector_i2nn</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate the pairwise displacement&quot;</span><span class="p">)</span>
            
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Transform the data and perform paiwise differences&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="c1"># NOTE: There is a discrepancy here I use log2 belwo log10</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vector_i2nn</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vector_i2nn</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;logratio&quot;</span><span class="p">:</span>
                <span class="n">log2hidim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim_t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">log2hidim</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">log2hidim</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">log2hidim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vector_i2nn</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not a valid parameter&quot;</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Correlation Calculation &#39;knn&#39;&quot;</span><span class="p">)</span>
            <span class="n">vector_i2nn</span> <span class="o">=</span> <span class="n">vector_i2nn</span> <span class="o">-</span> <span class="n">vector_i2nn</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># centered for correlation calculation (removing this line one calculates the cosine similarity)</span>
            <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">delta_hi_dim</span> <span class="o">-</span> <span class="n">delta_hi_dim</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># centered for correlation calculation (removing this line one calculates the cosine similarity)</span>

            <span class="c1"># NOTE: the code below could be made a one liner or numexpr, avoiding memory allocation</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">vector_i2nn</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># this is the dot product written using numpy broadcasting</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_i2nn</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">denominator</span><span class="p">[</span><span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

        <span class="k">elif</span> <span class="n">knn_random</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">=</span> <span class="s2">&quot;knn_random&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;pcs&quot;</span> <span class="ow">in</span> <span class="n">hidim</span><span class="p">:</span>  <span class="c1"># sic</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;clipped&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;unclipped&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_delta_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">delta_kind</span> <span class="o">==</span> <span class="s2">&quot;residual&quot;</span><span class="p">:</span>
                    <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">hi_dim</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_S</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                
            <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate KNN in the embedding space&quot;</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;connectivity&quot;</span><span class="p">)</span>

            <span class="c1"># Pick random neighbours and prune the rest</span>
            <span class="n">neigh_ixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sampling_pobs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampling_pobs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># NOTE: problem of API consistency because the random.choice can pick the diagonal value (or not)</span>
            <span class="c1"># resulting self.corrcoeff with different number of nonzero entry per row.</span>
            <span class="c1"># Not updated yet not to break previous analyses</span>
            <span class="c1"># Fix is substituting below `neigh_ixs.shape[1]` with `np.arange(1,neigh_ixs.shape[1]-1)`</span>
            <span class="n">sampling_ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                      <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sampled_fraction</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),),</span>
                                                      <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                      <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_ixs</span> <span class="o">=</span> <span class="n">sampling_ixs</span>
            <span class="n">neigh_ixs</span> <span class="o">=</span> <span class="n">neigh_ixs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">sampling_ixs</span><span class="p">]</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nonzero</span><span class="p">),</span>
                                                    <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nonzero</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                                                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                          <span class="n">neigh_ixs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Correlation Calculation &#39;</span><span class="si">{self.corr_calc}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorLog10partial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">psc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">),</span> <span class="n">neigh_ixs</span><span class="p">,</span> <span class="n">psc</span><span class="o">=</span><span class="n">psc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;logratio&quot;</span><span class="p">:</span>
                <span class="n">log2hidim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hi_dim_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">log2hidim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorpartial</span><span class="p">(</span><span class="n">log2hidim</span><span class="p">,</span> <span class="n">delta_hi_dim</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorpartial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">,</span> <span class="n">neigh_ixs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorSqrtpartial</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">psc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">),</span> <span class="n">neigh_ixs</span><span class="p">,</span> <span class="n">psc</span><span class="o">=</span><span class="n">psc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not a valid parameter&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Nans encountered in corrcoef and corrected to 1s. If not identical cells were present it is probably a small isolated cluster converging after imputation.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Done Correlation Calculation&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;pcs&quot;</span> <span class="ow">in</span> <span class="n">hidim</span><span class="p">:</span>  <span class="c1"># sic</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hi_dim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                <span class="n">hi_dim_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidim</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span>
                
            <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate KNN in the embedding space&quot;</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;connectivity&quot;</span><span class="p">)</span>
            
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Correlation Calculation &#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCorLog10</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_hi_dim</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;logratio&quot;</span><span class="p">:</span>
                <span class="n">log2hidim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hi_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">delta_hi_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hi_dim_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">log2hidim</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCor</span><span class="p">(</span><span class="n">log2hidim</span><span class="p">,</span> <span class="n">delta_hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">=</span> <span class="n">colDeltaCor</span><span class="p">(</span><span class="n">hi_dim</span><span class="p">,</span> <span class="n">hi_dim_t</span> <span class="o">-</span> <span class="n">hi_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not implemented with corr_calc=&#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;rank&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not implemented with corr_calc=&#39;full&#39;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tranform=</span><span class="si">{transform}</span><span class="s2"> is not a valid parameter&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_embedding_shift"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_embedding_shift">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_embedding_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_corr</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Kernel evaluation</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculate transition probability&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">==</span> <span class="s2">&quot;knn&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">/</span> <span class="n">sigma_corr</span><span class="p">)</span>
            <span class="c1"># If you want to mask by maximum distance do it here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="n">unitary_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">magnitude</span><span class="p">[</span><span class="n">magnitude</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># To avoid nans</span>
            <span class="n">unitary_vectors</span> <span class="o">/=</span> <span class="n">magnitude</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unitary_vectors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">knn_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># expected center from the knn</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Saving the results in `delta_emedding`&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">-</span> <span class="n">knn_center</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_calc</span> <span class="o">==</span> <span class="s2">&quot;knn_random&quot;</span><span class="p">:</span>
            <span class="c1"># NOTE maybe sparse matrix here are slower than dense</span>
            <span class="c1"># NOTE if knn_random this could be made much faster either using sparse matrix or neigh_ixs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corrcoef</span> <span class="o">/</span> <span class="n">sigma_corr</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">A</span>  <span class="c1"># naive</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="n">unitary_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># shape (2,ncells,ncells)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">unitary_vectors</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># divide by L2</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># fix nans</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">unitary_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span> <span class="o">*</span> <span class="n">unitary_vectors</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">-=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="n">unitary_vectors</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_knn</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># sparse matrix verison of the same code</span>
            <span class="c1"># self.transition_prob = np.expm1(sparse.csr_matrix.multiply(self.embedding_knn, self.corrcoef) / sigma_corr) + self.embedding_knn[0,:].sum()</span>
            <span class="c1"># self.transition_prob.multiply(1. / sparse.csr_matrix.sum(mknn, axis=1))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NOTE should implement a version with cython</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Weird value self.corr_calc=</span><span class="si">{self.corr_calc}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.calculate_grid_arrows"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.calculate_grid_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_grid_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span> <span class="n">smooth</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="n">Tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
                              <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the velocity using a points on a regular grid and a gaussian kernel</span>

<span class="sd">        Note: the function should work also for n-dimensional grid</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        embed: str, default=embedding</span>
<span class="sd">            The name of the attribute containing the embedding. It will be retrieved as getattr(self, embed)</span>
<span class="sd">            The updated vector at time t is assumed to be getattr(self, embed + &#39;_t&#39;)</span>
<span class="sd">            Or the difference vector is getattr(self, &#39;delta&#39; + &#39;_&#39; + embed)</span>
<span class="sd">        smooth: float, smooth=0.5</span>
<span class="sd">            Higher value correspond to thaking in consideration further points</span>
<span class="sd">            the standardad deviation of the gaussian karnel is smooth * stepsize</span>
<span class="sd">        steps: tuple, detaul</span>
<span class="sd">            the number of steps in the grid for each axis</span>
<span class="sd">        n_neighbors:</span>
<span class="sd">            number of neighbours to use in the calculation, bigger number should not change too much the results..</span>
<span class="sd">            ...as soon as smooth is small</span>
<span class="sd">            Higher value correspond to slower exectution time</span>
<span class="sd">        n_jobs:</span>
<span class="sd">            number of processes for parallel computing</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but it sets the attributes:</span>
<span class="sd">        flow_embedding, flow_grid, flow, flow_magnitude</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">):</span>
            <span class="n">delta_embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">embedding</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;delta_&quot;</span> <span class="o">+</span> <span class="n">embed</span><span class="p">):</span>
            <span class="n">delta_embedding</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;delta_&quot;</span> <span class="o">+</span> <span class="n">embed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;This embedding does not have a delta_* or a *_t&quot;</span><span class="p">)</span>
        <span class="c1"># Prepare the grid</span>
        <span class="n">grs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="n">dim_i</span><span class="p">])</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">0.025</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">steps</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])</span>
            <span class="n">grs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
            
        <span class="n">meshes_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grs</span><span class="p">)</span>
        <span class="n">gridpoints_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">flat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">meshes_tuple</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">neighs</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">gridpoints_coordinates</span><span class="p">)</span>
        
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([(</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grs</span><span class="p">])</span>
        <span class="c1"># isotropic gaussian kernel</span>
        <span class="n">gaussian_w</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">smooth</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">dists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span> <span class="o">=</span> <span class="n">gaussian_w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">UZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">neighs</span><span class="p">]</span> <span class="o">*</span> <span class="n">gaussian_w</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># weighed average</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">UZ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Assign attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span> <span class="o">=</span> <span class="n">gridpoints_coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">UZ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span> <span class="o">=</span> <span class="n">UZ</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_grid_arrows"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_grid_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">plot_grid_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quiver_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_mass</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">scatter_kwargs_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_dots</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># plt.figure(figsize=(10, 10))</span>
        <span class="n">scatter_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;zorder&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">scatter_kwargs_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scatter_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">scatter_kwargs_dict</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">scatter_dict</span><span class="p">)</span>
        
        <span class="n">mass_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_p_mass</span> <span class="o">&lt;</span> <span class="n">min_mass</span>
        <span class="k">if</span> <span class="n">min_magnitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">XY</span><span class="p">,</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_dots</span><span class="p">:</span>
                <span class="n">UV</span> <span class="o">=</span> <span class="n">UV</span><span class="p">[</span><span class="o">~</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">XY</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="o">~</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UV</span><span class="p">[</span><span class="n">mass_filter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XY</span><span class="p">,</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_dots</span><span class="p">:</span>
                <span class="n">UV</span> <span class="o">=</span> <span class="n">UV</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">)),</span> <span class="p">:]</span>
                <span class="n">XY</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">)),</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UV</span><span class="p">[</span><span class="n">mass_filter</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_norm_magnitude</span> <span class="o">&lt;</span> <span class="n">min_magnitude</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">UV</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">UV</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">scale</span><span class="o">=</span><span class="n">quiver_scale</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_arrows_embedding"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_arrows_embedding">[docs]</a>    <span class="k">def</span> <span class="nf">plot_arrows_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plot_scatter</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">color_arrow</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="n">quiver_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">new_fig</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plots the results of the arrows_from_hidim_to_embedding</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        choice: int, default = 1000</span>
<span class="sd">            the number of cells to randomly pick to plot the arrows</span>
<span class="sd">        plot_scatter: bool, default = False</span>
<span class="sd">            wether to plot the points</span>
<span class="sd">        color_arrow: str, default = &quot;cluster</span>
<span class="sd">            the color of the arrows, if &quot;cluster&quot; the arrows are colored the same as the cluster</span>
<span class="sd">        epsilon: float, default = None</span>
<span class="sd">            the minimal size of the arrow that can be plotted before it becomes invisible</span>
<span class="sd">        quiver_scale: float</span>
<span class="sd">            scale argument passed to the matplotlib quiver function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing, just plots the tsne with arrows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_fig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">plot_scatter</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
        <span class="n">ix_choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">choice</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">color_arrow</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="n">colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colorandum</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colorandum</span> <span class="o">=</span> <span class="n">color_arrow</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">ix_choice</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">quiver_scale</span><span class="p">,</span> <span class="o">**</span><span class="n">quiver_kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VelocytoLoom.plot_cell_transitions"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_cell_transitions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cell_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ix</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha_neigh</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              <span class="n">cmap_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;RdBu_r&quot;</span><span class="p">,</span> <span class="n">plot_arrow</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">mark_cell</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">head_width</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot the probability of a cell to transition to any other cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cmap_name</span><span class="p">)</span>
        <span class="n">colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">colorandum</span> <span class="o">*=</span> <span class="mf">0.3</span>
        <span class="n">colorandum</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">colorandum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_ix</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="p">:],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_prob</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">colorandum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_ix</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_neigh</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">colorandum</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mark_cell</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_arrow</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_embedding</span><span class="p">[</span><span class="n">cell_ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="n">head_width</span><span class="o">=</span><span class="n">head_width</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VelocytoLoom.plot_velocity_as_color"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_velocity_as_color">[docs]</a>    <span class="k">def</span> <span class="nf">plot_velocity_as_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">RdBu_r</span><span class="p">,</span> <span class="n">gs</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot velocity as color on the Tsne</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        which_tsne: str</span>
<span class="sd">            can be &quot;tsW&quot; or other tsne attribute accessible by getattr(self, which_tsne)</span>
<span class="sd">        cmap: maplotlib.cm.Colormap</span>
<span class="sd">            Colormap to use, devergent are better, RdBu_r is default</span>
<span class="sd">            Notice that 0 will be always set as the center of the colormap. (e.g. white in RdBu_r)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwarg_plot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;0.8&quot;</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">}</span>
        <span class="n">kwarg_plot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    
        <span class="n">tsne</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz_t</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_t</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00005</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># If S vs U scatterplot it is flat</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S vs U scatterplot it is flat&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">99</span><span class="p">])))</span>  <span class="c1"># upper and lowe limit / saturation</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">+</span> <span class="n">limit</span>  <span class="c1"># that is: tmp_colorandum - (-limit)</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">limit</span><span class="p">)</span>  <span class="c1"># that is: tmp_colorandum / (limit - (-limit))</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">scatter_viz</span><span class="p">(</span><span class="n">tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">),</span> <span class="o">**</span><span class="n">kwarg_plot</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{gene_name}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.plot_expression_as_color"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.plot_expression_as_color">[docs]</a>    <span class="k">def</span> <span class="nf">plot_expression_as_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imputed</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greens</span><span class="p">,</span> <span class="n">gs</span><span class="p">:</span> <span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Plot expression (imputed) as color on the Tsne</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        gene_name: str</span>
<span class="sd">            The name of the gene, should be present in self.S</span>
<span class="sd">        cmap: maplotlib.cm.Colormap</span>
<span class="sd">            Colormap to use, devergent are better, RdBu_r is default</span>
<span class="sd">            Notice that 0 will be always set as the center of the colormap. (e.g. white in RdBu_r)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwarg_plot</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;0.8&quot;</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">}</span>
        <span class="n">kwarg_plot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
    
        <span class="n">tsne</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_tsne</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imputed</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_S_for_pred</span> <span class="o">==</span> <span class="s2">&quot;Sx_sz&quot;</span><span class="p">:</span>
                <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_sz</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>
            
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">tmp_colorandum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="c1"># tmp_colorandum = np.log2(tmp_colorandum+1)</span>
        <span class="n">tmp_colorandum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">scatter_viz</span><span class="p">(</span><span class="n">tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">tmp_colorandum</span><span class="p">),</span> <span class="o">**</span><span class="n">kwarg_plot</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{gene_name}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VelocytoLoom.reload_raw"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.VelocytoLoom.reload_raw">[docs]</a>    <span class="k">def</span> <span class="nf">reload_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substitute</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">substitute</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loom_filepath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_S</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_U</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_A</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layer</span><span class="p">[</span><span class="s2">&quot;ambiguous&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_ca</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_attrs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">row_attrs</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="scatter_viz"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.scatter_viz">[docs]</a><span class="k">def</span> <span class="nf">scatter_viz</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A wrapper of scatter plot that guarantees that every point is visible in a very crowded scatterplot</span>

<span class="sd">    Args</span>
<span class="sd">    ----</span>
<span class="sd">    x: np.ndarray</span>
<span class="sd">        x axis coordiantes</span>
<span class="sd">    y: np.ndarray</span>
<span class="sd">        y axis coordiantes</span>
<span class="sd">    args and kwargs:</span>
<span class="sd">        positional and keyword arguments as in matplotplib.pyplot.scatter</span>

<span class="sd">    Retruns</span>
<span class="sd">    -------</span>
<span class="sd">    Plots the graph and returns the axes object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ix_x_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">ix_yx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">args_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kwargs_new</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">args_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">karg</span><span class="p">,</span> <span class="n">varg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">varg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">kwargs_new</span><span class="p">[</span><span class="n">karg</span><span class="p">]</span> <span class="o">=</span> <span class="n">varg</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs_new</span><span class="p">[</span><span class="n">karg</span><span class="p">]</span> <span class="o">=</span> <span class="n">varg</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ix_x_sort</span><span class="p">][</span><span class="n">ix_yx_sort</span><span class="p">],</span> <span class="o">*</span><span class="n">args_new</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="ixs_thatsort_a2b"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.ixs_thatsort_a2b">[docs]</a><span class="k">def</span> <span class="nf">ixs_thatsort_a2b</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">check_content</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s2">&quot;This is super duper magic sauce to make the order of one list to be like another&quot;</span>
    <span class="k">if</span> <span class="n">check_content</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">f</span><span class="s2">&quot;The two arrays are not matching&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span></div>

<span class="n">colors20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Vega20b</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Vega20c</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>


<div class="viewcode-block" id="colormap_fun"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.colormap_fun">[docs]</a><span class="k">def</span> <span class="nf">colormap_fun</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">colors20</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="s2">&quot;float64[:](float64[:], int32[:], int32[:], float64[:])&quot;</span><span class="p">,</span> <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_scale_to_match_median</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Helper function that operates directly on the .data array of a sparse matrix object</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Loop through the columns</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">genes_total</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Retrieve the values</span>
        <span class="n">non_zero_genes_total</span> <span class="o">=</span> <span class="n">genes_total</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]]</span>
        <span class="c1"># Find the normalization factor</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">non_zero_genes_total</span><span class="p">)</span> <span class="o">/</span> <span class="n">non_zero_genes_total</span><span class="p">)</span>
        <span class="n">new_data</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">new_data</span>


<div class="viewcode-block" id="scale_to_match_median"><a class="viewcode-back" href="../../fullapi/api_analysis.html#velocyto.analysis.scale_to_match_median">[docs]</a><span class="k">def</span> <span class="nf">scale_to_match_median</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">:</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Normalize contribution of different neighbor genes to match the median totals</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    sparse_matrix: sparse.csr_matrix</span>
<span class="sd">        weights matrix</span>
<span class="sd">    </span>
<span class="sd">    genes_total: sparse.csr_matrix shape=(sparse_matrix.shape[0])</span>
<span class="sd">        array of the total molecules detected for each gene</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knn_weights: sparse.csr_matrix</span>
<span class="sd">        sparse_matrix after the normalization</span>
<span class="sd">    </span>
<span class="sd">    # NOTE, since the use I made of this later I could have changed sparse_matrix in place</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newdata</span> <span class="o">=</span> <span class="n">_scale_to_match_median</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">genes_total</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">newdata</span><span class="p">,</span>
                              <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                              <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span>
                             <span class="n">shape</span><span class="o">=</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                             <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Linnarsson Lab.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.9.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>